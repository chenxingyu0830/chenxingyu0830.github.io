<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-04-23T12:15:14.137Z</updated>
  <id>/</id>
  
  <author>
    <name>SmallYU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript模拟实现继承及ES6写法</title>
    <link href="/2019/04/18/JavaScript%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%8F%8AES6%E5%86%99%E6%B3%95/"/>
    <id>/2019/04/18/JavaScript模拟实现继承及ES6写法/</id>
    <published>2019-04-18T09:13:20.000Z</published>
    <updated>2019-04-23T12:15:14.137Z</updated>
    
    <content type="html"><![CDATA[<p>介绍JS中继承的写法，包括使用prototype如何继承？使用Class语法糖如何继承？比较这两者之间的区别。<br><a id="more"></a></p><!-- toc --><blockquote><p>在ES6之前，JavaScript是没有类和继承这个概念的。ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为JavaScript引入新的面向对象的继承模型。所以我们在ES6之前实现类和类的继承是通过原型链来实现的。</p></blockquote><h2 id="如何使用prototype实现继承？"><a href="#如何使用prototype实现继承？" class="headerlink" title="如何使用prototype实现继承？"></a>如何使用prototype实现继承？</h2><p>  首先我们需要定义一个对象，对象里存放对象自身的属性，同时对象的私有属性<em>proto</em>指向它的原型prototype，就可以存放对象的共有属性。例如：</p><pre><code>function Human(name){  this.name = name}Human.prototype.say = function(){  console.log(&quot;我叫&quot; + this.name + &quot;,我在说话”)    }</code></pre><p>  这样我们就实现了一个对象的定义和添加了对象的方法。如果我们要让对象的子对象拥有对象的方法，怎么实现呢？答案很简单，我们只要让子对象的私有属性<em>proto</em>指向父对象即可。</p><pre><code>function Man(name){  Human.call(this, name)  this.sex = &apos;男&apos;    }Man.prototype._proto_ = Human.prototype</code></pre><p>  但是IE不支持<strong>man.prototype.<em>proto</em> = Human.prototype</strong>这种写法。所以我们只能通过新建一个空函数并让子对象指向空函数的方式来实现。</p><pre><code>var f = {}f.prototype = Human.prototypeman.prototype = new f()</code></pre><p>  实现原理是因为new运算符会</p><pre><code>// 1. 首先创建一个空函数var object = new Fn();// 2. 将空对象的原型赋值为构造器函数的原型object.__proto__ = Fn.prototype;// 3. 更改构造器函数内部this，将其指向新创建的空对象Fn.call(this);// 4. 返回结果return this</code></pre><p>  所以我们创建空函数的过程中就会让空函数指向它的原型对象。我们只要让<strong>Fn.prototype = new f()</strong>就可以。但是因为<strong>Fn.call(this)</strong>的存在，会让子对象也有父对象的方法，这是我们不想要的结果。所以，我们需要一个中间过渡的空函数。</p><p>  让子对象的原型指向空函数，空函数的原型指向父对象。这样就能子对象中避免call(this)返回我们不想要的父对象的方法。</p><pre><code>function Human(name){    this.name = name}Human.prototype.say = function(){    console.log(&quot;我叫&quot;+this.name+&quot;，我在说话&quot;)    return undefined}function Man(name){    Human.call(this, name)    this.sex = &apos;男&apos;}var f = function(){}f.prototype = Human.prototypeMan.prototype = new f()Man.prototype.sleep = function(){    console.log(&apos;我在睡觉&apos;)}</code></pre><h2 id="使用Class语法糖如何继承？"><a href="#使用Class语法糖如何继承？" class="headerlink" title="使用Class语法糖如何继承？"></a>使用Class语法糖如何继承？</h2><p>  首先Class是ES6出现的语法糖。用Class实现继承的语法非常简单。代码如下：</p><pre><code>class Human{  constructor(name){    this.name = name  }  say(){    console.log(&quot;我叫&quot; + this.name + &quot;，我在说话&quot;)  }}class Man extends Human{  constructor(name){    super(name)    this.sex = &apos;男&apos;       }  sleep(){    console.log(&apos;我在睡觉&apos;)  }}</code></pre><p><strong>expends</strong>表示Man对象接上Human对象的原型链<strong>constructor</strong>调用了父类的构造函数。<strong>super</strong>表示传递的属性。</p><h2 id="比较这两者之间的区别。"><a href="#比较这两者之间的区别。" class="headerlink" title="比较这两者之间的区别。"></a>比较这两者之间的区别。</h2><p>  如果我们想在原型上声明一个属性，后者不支持声明属性。只能采取较为变通的写法:</p><p>Class声明变量</p><pre><code>class Man extends Human{  constructor(name){    super(name)    this.sex = &apos;男&apos;       }  get 种族(){    return &apos;人类&apos;  }  sleep(){    console.log(&apos;我在睡觉&apos;)  }}</code></pre><p>ES5声明变量</p><pre><code>function Human(name){    this.name = name}Human.prototype.种族 = &apos;人类&apos;Human.prototype.say = function(){    console.log(&quot;我叫&quot;+this.name+&quot;，我在说话&quot;)    return undefined}</code></pre><p>  结论：前者比后者清晰，后者比前者简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍JS中继承的写法，包括使用prototype如何继承？使用Class语法糖如何继承？比较这两者之间的区别。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS之堆叠上下文</title>
    <link href="/2018/11/12/CSS%E4%B9%8B%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>/2018/11/12/CSS之堆叠上下文/</id>
    <published>2018-11-12T12:22:11.000Z</published>
    <updated>2018-11-12T12:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么我们要了解什么是堆叠上下文？</p><p>1.这可以让我们明确实际开发网页中，每个元素的显示顺序到底是什么样的。</p><p>2.可以了解为什么开发过程中会有这样或者那样的显示问题？并且解决它！<br><a id="more"></a></p><!-- toc --><h2 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h2><p>元素和元素属性的堆叠顺序是不同的。如下所示，数字越大代表越靠前显示。</p><pre><code>1. background2. border3. 块级4. 浮动5. 内联6. z-index: 07. z-index: +</code></pre><p>如果是兄弟元素重叠，那么后面的盖在前面的身上。</p><p>z-index：-1，那么要分情况。</p><p>如果div是没有定位的，那么z-index：-1 会出现在background后面。</p><p>如果div是定位了的，那么z-index：-1 会出现在DIV的后面（也就是2和3之间）。</p><p><img src="https://i.loli.net/2018/11/12/5be974da10110.jpg" alt=""></p><h2 id="堆叠上下文"><a href="#堆叠上下文" class="headerlink" title="堆叠上下文"></a>堆叠上下文</h2><p>可以理解为堆叠作用域。跟 BFC 一样，我们只知道一些属性会触发堆叠上下文，但并不知道堆叠上下文是什么。</p><pre><code>根元素 (HTML),z-index 值不为 &quot;auto&quot;的 绝对/相对定位，一个 z-index 值不为 &quot;auto&quot;的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，opacity 属性值小于 1 的元素（参考 the specification for opacity），transform 属性值不为 &quot;none&quot;的元素，mix-blend-mode 属性值不为 &quot;normal&quot;的元素，filter值不为“none”的元素，perspective值不为“none”的元素，isolation 属性被设置为 &quot;isolate&quot;的元素，position: fixed在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）-webkit-overflow-scrolling 属性被设置 &quot;touch&quot;的元素</code></pre><h2 id="怎么理解html中div的堆叠上下文？"><a href="#怎么理解html中div的堆叠上下文？" class="headerlink" title="怎么理解html中div的堆叠上下文？"></a>怎么理解html中div的堆叠上下文？</h2><p><strong>比如两个div如图所示，两个父div不是默认定位。它们两个之间先比较他们的z-index值，大的优先显示。</strong></p><p>就好像一个公司里的2个大部门，谁的KPI高，谁就受到总裁重视，自然地位高。</p><p><strong>但是为什么它们的z-index值相同，也是b元素先显示呢？</strong></p><p>再打个比方，b部门是后成立的。好比新官上任三把火，表现要比老部门更抢眼一点，所以b的地位更高一点。</p><p><strong>那两个父div比较完了，它们分别的子元素直接z-index值有什么关系呢？答案是子元素只跟自己父元素里的其他子元素z-index值比较大小。跟其他父元素的子元素显示先后就要看它们父元素的z-index值了。</strong></p><p>这怎么理解？可以认为b部门比a部门表现抢眼，那么总裁就认为b部门的人工作能力就是a部门的人要强！（活生生的实例啊，说明选择比努力更加重要。。）</p><p><strong>总结：如果父元素是默认定位，那么子元素可以跨元素进行比较z-index值；如果父元素不是默认定位，那么子元素只跟自己父元素内的子元素进行比较z-index值。</strong></p><p>就像一个公司刚成立，哪有那么多的部门划分，撸起袖子就是干！谁的能力强，谁的KPI就高，老板就更欣赏谁，谁的地位也越高。但是公司发展之后，成立了大大小小各个部门。可能有的部门比其他部门要抢眼，或者有的部门是后成立的。这时候老板只看部门不看人，哪个部门产值高，哪个部门在老板眼中地位就高，至于个人的优秀与否老板不管。个人的能力只在其部门里，让他的主管去考量，跟同部门的人去竞争。（再次说明跟住一个好领导的重要性，个人地位也跟着部门地位水涨船高。）</p><p><img src="https://i.loli.net/2018/11/12/5be975bfac715.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么我们要了解什么是堆叠上下文？&lt;/p&gt;
&lt;p&gt;1.这可以让我们明确实际开发网页中，每个元素的显示顺序到底是什么样的。&lt;/p&gt;
&lt;p&gt;2.可以了解为什么开发过程中会有这样或者那样的显示问题？并且解决它！&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS之宽度与高度</title>
    <link href="/2018/11/11/CSS%E4%B9%8B%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%AB%98%E5%BA%A6/"/>
    <id>/2018/11/11/CSS之宽度与高度/</id>
    <published>2018-11-11T14:35:05.000Z</published>
    <updated>2018-11-11T15:49:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍CSS里 元素的宽度与高度到底由什么确定，有哪些实用方法，另外附上一些小技巧和概念理解。<br><a id="more"></a></p><!-- toc --><h2 id="div的高度"><a href="#div的高度" class="headerlink" title="div的高度"></a>div的高度</h2><blockquote><p>每种字体的建议行高不同，有的是1.4倍，有的是1.3倍。都是字体设计师设计的。如图所示</p></blockquote><p><img src="https://i.loli.net/2018/11/11/5be84099f086c.jpg" alt=""></p><p>你可以规定行高是多少，把行高限定死。</p><p><img src="https://i.loli.net/2018/11/11/5be840e36bad2.jpg" alt=""></p><p>div里写空格要用转移字符。</p><p><img src="https://i.loli.net/2018/11/11/5be8412e2b975.jpg" alt=""></p><p>当你要让文字对齐的时候用到的技巧：</p><p>1.让2个span元素line-height:justify属性，当时单行显示不出效果，只有多行才能对齐。</p><p>2.这时候你再后面追加一个伪元素，让他为inline-block属性。伪元素宽度为span的5em，多行时line-height:justify对齐。</p><p><img src="https://i.loli.net/2018/11/11/5be841db24075.jpg" alt=""></p><p>只要是inline元素，两个之间只要不是连在一起，就会出现空格，如图</p><p><img src="https://i.loli.net/2018/11/11/5be843b927423.jpg" alt=""></p><p>不用display：inline-block，用float：left，然后父元素清除浮动(clearfix)，就能实现没有空格的效果。</p><p><img src="https://i.loli.net/2018/11/11/5be84414b518c.jpg" alt=""></p><h2 id="文字省略溢出"><a href="#文字省略溢出" class="headerlink" title="文字省略溢出"></a>文字省略溢出</h2><p>white-space:nowrap属性——不换行，超出部分往右显示。div宽度不会随文字变长。</p><p><img src="https://i.loli.net/2018/11/11/5be84461c817d.jpg" alt=""></p><pre><code>overflow:hidden            //超出部分省略text-overflow:ellipsis    //超出部分变成省略号</code></pre><p><img src="https://i.loli.net/2018/11/11/5be84508b3e49.jpg" alt=""></p><p>搜多行文本怎么省略</p><p><img src="https://i.loli.net/2018/11/11/5be84539c17a8.jpg" alt=""></p><h2 id="文字垂直居中"><a href="#文字垂直居中" class="headerlink" title="文字垂直居中"></a>文字垂直居中</h2><p>outline不占据空间，border占据空间</p><p>父元素不限定高度的时候怎么居中，就用padding！</p><p><strong>不要用height和line-height！！！</strong></p><p><strong>不要用height和line-height！！！</strong></p><p><strong>不要用height和line-height！！！</strong></p><p><img src="https://i.loli.net/2018/11/11/5be845e552c45.jpg" alt=""></p><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><p>子元素的padding属性会影响父元素的高度，毋庸置疑。</p><p>子元素的margin属性会影响父元素高度吗？</p><p>答案是不一定！分情况！</p><p>1.当父元素有border属性时，子元素的margin会影响父元素高度（很好理解）</p><p>2.当父元素没有border属性时，父元素高度如图所示。左右间距受到padding属性影响，但是上下间距却纹丝不动。这是因为magIn合并了。</p><p>如果父元素没有东西挡住子元素margin，那么子元素的margin就会超出父元素高度。</p><p><img src="https://i.loli.net/2018/11/11/5be8462d240e0.jpg" alt=""></p><p>这时候如果给父元素的父元素(如body)添加一个border，就会发现父元素和body之间存在子元素的margin间距</p><p><img src="https://i.loli.net/2018/11/11/5be8465dde701.jpg" alt=""></p><p>解决方法：</p><p>给父元素一个属性（只要能挡住margin，不让合并就行）如margin padding。就能取消margin合并</p><p><img src="https://i.loli.net/2018/11/11/5be8465dde701.jpg" alt=""></p><p>还有种方法 overflow:hidden，顾名思义：让溢出后的内容隐藏掉。（但是不推荐这么做）</p><p>因为你加了这个属性后所有内容都在写在父元素内，要做一些功能（如悬浮窗）就实现不了。</p><p>所以 </p><p>overflow:hidden不到万不得已就不用！</p><p>overflow:hidden不到万不得已就不用！</p><p>overflow:hidden不到万不得已就不用！</p><p>加个padding就好了</p><p><img src="https://i.loli.net/2018/11/11/5be8469de01ab.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>1.div高度是由内部文档流中元素的总和决定的。</p><p>2.文档流中每个div（块级元素）都会另起一行。内联元素从左到右，块级元素从上到下每一个都另起一行。</p><p>怎么让元素脱离文档流？很多方式。脱离文档流的意思是让父元素的高度不计算脱离文档流内容的高度。(算高度时候别叫上我)</p><p><img src="https://i.loli.net/2018/11/11/5be8472809d0c.jpg" alt=""></p><p>注意：相对定位的子元素不脱离文档流。父元素算上其高度，其位置可以相对于父元素发生变化。不影响其他子元素的位置。</p><p><img src="https://i.loli.net/2018/11/11/5be8474b91ce4.jpg" alt=""></p><h3 id="确定元素宽高"><a href="#确定元素宽高" class="headerlink" title="确定元素宽高"></a>确定元素宽高</h3><h4 id="内联元素的宽高"><a href="#内联元素的宽高" class="headerlink" title="内联元素的宽高"></a>内联元素的宽高</h4><p>内联元素的宽度受padding和margin影响，但是高度不受影响！！！</p><h4 id="块级元素的宽高"><a href="#块级元素的宽高" class="headerlink" title="块级元素的宽高"></a>块级元素的宽高</h4><p>div的宽度不要去改它，会自适应父元素宽度。</p><p>div的高度：如果div内是内联元素，就所有行高加起来；如果是块级元素，就把它的内容，border，padding,margin(看不合并)影响div高度。</p><p>总结：块级元素的高度由它内部文档流元素高度的总和决定的。</p><h3 id="如何绝对居中（上下左右都居中）"><a href="#如何绝对居中（上下左右都居中）" class="headerlink" title="如何绝对居中（上下左右都居中）"></a>如何绝对居中（上下左右都居中）</h3><p>1.父元素不限定高度的情况下：</p><p>让子元素添加padding,实现上下居中。让父元素margin左右自适应实现 子元素左右居中。</p><p><img src="https://i.loli.net/2018/11/11/5be847d498319.jpg" alt=""></p><p>2.确定父元素的高度后怎么绝对居中？（只有一种情况下需要这么做，父元素是全屏显示body）</p><p>第一种办法：先让父元素变成box-sizing:border-box盒模型；然后子元素四个方向margin都auto（但是没用 CSS BUG,只能左右auto不能上下auto）,解决方法：设置为绝对定位。但是子元素必须设置height，不能确定子元素高度就不能用这种方法。</p><p><img src="https://i.loli.net/2018/11/11/5be84a0e322e4.jpg" alt=""><br>第二种办法：用flex布局，3句话绝对居中（IE不支持，用JS做）如果IE要支持，去搜CSS垂直居中的7种方法。</p><p><img src="https://i.loli.net/2018/11/11/5be84e8a85504.jpg" alt=""></p><p>可以做出对话框效果</p><p><img src="https://i.loli.net/2018/11/11/5be84efe086d5.jpg" alt=""></p><h3 id="如何实现一个一比一的div"><a href="#如何实现一个一比一的div" class="headerlink" title="如何实现一个一比一的div"></a>如何实现一个一比一的div</h3><p>padding-top:100%;</p><p>分析：div高度是0，从下到上全是padding-top。padding-top:100%是让padding和宽度一样。</p><p>就实现了宽度自适应，高度为0。用padding-top实现高度定位。</p><p><img src="https://i.loli.net/2018/11/11/5be84f628e50f.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍CSS里 元素的宽度与高度到底由什么确定，有哪些实用方法，另外附上一些小技巧和概念理解。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链到底是什么？</title>
    <link href="/2018/11/10/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>/2018/11/10/原型与原型链到底是什么？/</id>
    <published>2018-11-10T07:23:05.000Z</published>
    <updated>2018-11-10T09:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>可能你听说过原型和原型链，但是MDN的解释对于初学者来讲又很难理解。下面我介绍一下自己的理解，可能有失偏颇，敬请谅解。<br><a id="more"></a></p><!-- toc --><h2 id="全局对象Window"><a href="#全局对象Window" class="headerlink" title="全局对象Window"></a>全局对象Window</h2><p>ECMAScript规定全局对象叫做global，而在浏览器中称全局对象为window（浏览器先存在）</p><p>ECMAScript规定有以下常用属性:</p><pre><code>parseIntparseFloatNumber()String()Boolean()Object()</code></pre><p>浏览器自己添加以下常用属性:</p><pre><code>alert            //弹框promit            //用户填写confirm            //弹框确认console.log()    //开发者打印东西document        //文档，与DOM有关history            //浏览器下命令，与BOM有关</code></pre><ul><li><p>window对象中的方法可以省略window，例如window.alert()方法可以写为alert()方法,比较简便。</p></li><li><p>浏览器下添加的属性，在每个浏览器下效果可能会不一样，因为他们没有统一的标准。</p></li></ul><h2 id="简单类型与对象的区别"><a href="#简单类型与对象的区别" class="headerlink" title="简单类型与对象的区别"></a>简单类型与对象的区别</h2><pre><code>//声明简单的数据类型var n1 = 1;//声明一个对象，可以用n2.toString()将其转换成字符串var n2 = new Number(1);</code></pre><p><img src="https://i.loli.net/2018/11/10/5be691206f545.jpg" alt="简单类型与对象"></p><p>他们两者的存储方式不同。n1是简单声明的数据类型，直接存放在Stack内存中。n2是声明了一个对象，Stack内存中只存放它所指向的Heap内存地址，Heap内存中存放内容。</p><ul><li>声明对象除了存放内容，还存放了一些公共属性，如：toString()、valueOf()等。这些在我们接下来的文章中有提到。</li></ul><h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><table><thead><tr><th>Number的常用属性</th><th>含义</th></tr></thead><tbody><tr><td>Number.valueOf()</td><td>获取对象的值</td></tr><tr><td>Number.toString()</td><td>转换为字符串</td></tr><tr><td>Number.toFixed()</td><td>转换为小数</td></tr><tr><td>Number.toExponential()</td><td>转换为科学计数法</td></tr></tbody></table><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><table><thead><tr><th>String的常用属性</th><th>含义</th></tr></thead><tbody><tr><td>String.charAt()</td><td>获取数组中某一位置字符</td></tr><tr><td>String.charCodeAt()</td><td>获取数组中某一位置字符的Unicode编码</td></tr><tr><td>String.trim()</td><td>去空格</td></tr><tr><td>String1.concat(String2)</td><td>连接字符串</td></tr><tr><td>String.slice(start,end)</td><td>切片</td></tr><tr><td>String.replace(‘e’,’o’)</td><td>替换对应的字符</td></tr><tr><td>String.indexOf()</td><td>查询字符是否在字符串中</td></tr><tr><td>String.split()</td><td>分隔</td></tr><tr><td>String.substr(start[, length])</td><td>截取某一部分字符串</td></tr></tbody></table><h3 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h3><pre><code>var f1 = falsevar f2 = new Boolean(false)if(f1) { console.log(&apos;1&apos;) } if(f2) { console.log(&apos;2&apos;) } f1 === f2                        //false    </code></pre><p>注意：f1并不等于f2，因为f2是一个对象。一切对象都是的布尔值都是true。只有6个falsy值：</p><pre><code>0  NaN  &apos;&apos;  null  undefined  false</code></pre><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><pre><code>var obj1 = {};var obj2 = {};obj1 === obj2; // false</code></pre><p>obj1不等于obj2的原因：</p><p>因为它们存放的地址不同，所以两个对象是不相等的。</p><p><img src="https://i.loli.net/2018/11/10/5be695e3e1063.jpg" alt=""></p><h2 id="原型-公共属性"><a href="#原型-公共属性" class="headerlink" title="原型(公共属性)"></a>原型(公共属性)</h2><p>什么是原型？</p><p>所有对象都有 <code>toString</code> 和 <code>valueOf</code> 属性，那么我们是否需要给每个对象单独添加这些属性呢?答案是否定的，因为这么做将会占用大量的内存。</p><p>JS解决的方法:</p><p>设计一个隐藏的属性：<code>__proto__</code> ，来存放公用属性，它的值就是公用属性的值，它指向存放公共属性的地址。当你用一个类型调用公用属性（如:toString）时，如果不是对象就包装成对象，做一个临时的转换。如果是对象的话，就看有没有想要调用的，对应的属性。如果有，就调用。如果没有，就去<strong>proto</strong>属性去查看有没有，有就去相应地址去调用对应属性。</p><p><img src="https://i.loli.net/2018/11/10/5be69752ef827.jpg" alt=""></p><h3 id="proto-与-prototype-区别"><a href="#proto-与-prototype-区别" class="headerlink" title="proto 与 prototype 区别"></a><strong>proto</strong> 与 prototype 区别</h3><p>我们创建一个对象时，创建的对象的<code>__proto__</code>属性会指向对应<code>浏览器所创建的类型对象</code>。这时我们就可以调用<code>浏览器所创建的类型对象</code>的共有属性。</p><ul><li><code>__proto__</code>是对象共有属性的引用。目的是为了引用<code>浏览器所创建的类型对象</code>的共有属性。 </li><li><code>prototype</code>是浏览器所创建的，本身就存在。和<code>__proto__</code>用法上没有区别，只是形式上有区别。<code>prototype</code>是浏览器亲爹生的，<code>__proto__</code>是用户创建的对象产生的。<code>prototype</code>存在的意义是为了防止对象的共有属性没有被调用而被垃圾回收，导致浏览器的崩溃。</li></ul><p><img src="https://i.loli.net/2018/11/10/5be698babf62b.jpg" alt=""></p><h3 id="对象调用原型的流程"><a href="#对象调用原型的流程" class="headerlink" title="对象调用原型的流程"></a>对象调用原型的流程</h3><p>另外还有一些单独类别才有的公共属性，如number类型有toFixed属性，而string类型没有该属性。那么怎么把每个类型的公共属性区分开呢？</p><p>将每个类别共有的放在一起，独有的属性分别赋予类别？答案是将其类型先指向number共有属性（它独有的属性），number共有属性再添加<strong>proto</strong>属性，地址再指向公共属性。拿number类型的tofixed()和valueOf()属性为例:</p><ol><li>他先从对象的属性里找，找不到。</li><li>再去number共有属性里的<strong>proto</strong>属性里找，这时候找到tofixed()属性，返回。</li><li>找不到valueOf()属性，再去Object公共属性里找。这样总共3个步骤。</li></ol><p><img src="https://i.loli.net/2018/11/10/5be69c0f1ddf0.jpg" alt="对象调用原型的流程"></p><p>总结:</p><ol><li>每个类型共有属性（String共有属性，Number共有属性，Boolean共有属性）都有属于自己独特的属性。</li><li>变量的属性先调用自己类型的共有属性，如果找不到，通过<code>__proto__</code>属性指向的地址，调用object共有属性。</li><li>普通对象直接调用object共有属性。</li><li>object共有属性里没有<code>__proto__</code>属性。</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>概念:   </p><p>每个实例对象<code>object</code>都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象<code>prototype</code>。该原型对象也有一个自己的原型对象<code>__proto__</code> ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p><p>简单来说，原型链就是对象一直指向它的原型对象，直到原型对象为null。就像一条链子，每个共有属性都是链子上的节点。</p><p>也可以这么理解，变量的<code>__proto__</code>私有属性指向的就是它的原型对象<code>prototype</code></p><p>如: <code>number.__proto__.__proto__ === Object。prototype</code></p><p><img src="https://i.loli.net/2018/11/10/5be69c7d92b14.jpg" alt=""></p><p>变量在调用属性的时候，会通过原型链一层层找原型对象里的对应属性，如果找不到则undefined。</p><p>其实原型链就用到了数据结构里的树。私有属性<code>__proto__</code>指向对应树的节点。</p><p><img src="https://i.loli.net/2018/11/10/5be69cba7c659.jpg" alt=""></p><p>在没有写任何代码的情况下，浏览器初始化原型对象。</p><p>String.prototype是 String 的公用属性。   <code>s.__proto__</code>是String的公用属性的引用。</p><p>prototype为了防止垃圾回收，<code>__proto__</code>为了引用属性。</p><h2 id="一些烧脑的等式"><a href="#一些烧脑的等式" class="headerlink" title="一些烧脑的等式"></a>一些烧脑的等式</h2><p>通过var 对象 = new 函数；推出其他烧脑的等式</p><pre><code>var n = new Number(1)//var 对象 = new 函数//对象的__proto__指向某对象的共用属性，构造某对象的函数的prototype也指向某对象的共用属性//__proto__ 是对象的属性，prototype是函数的属性对象.__proto__ === 函数.prototype//函数的prototype是对象，这个对象对应的就是最简单的函数Object函数.prototype.__proto__ === Object.prototype//由于函数本身即是函数（最优先被视为函数），也是对象，而函数的构造函数是Function函数.__proto__ === Function.prototype//Function即是对象，也是函数，但他优先是个函数Function.__proto__ === Function.prototype//Function.prototype也是对象，是普通的对象，所以其对应的函数是ObjectFunciton.prototype.__proto__=== Object.prototype</code></pre><p>通过推导，我们可以知道Function即是函数，也是对象。<code>Function.prototype</code> 与<code>Funciton.__proto__</code>互相引用。</p><p>所以得出结论,Function是Object的构造函数。</p><p><code>Object.__proto__ === Function.prototype</code>，</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/dffeae0f1316" target="_blank" rel="noopener">https://www.jianshu.com/p/dffeae0f1316</a></p><p>by 《你真的完全理解原型与原型链？》—— 区家乐</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能你听说过原型和原型链，但是MDN的解释对于初学者来讲又很难理解。下面我介绍一下自己的理解，可能有失偏颇，敬请谅解。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS里的数据类型转换</title>
    <link href="/2018/11/07/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>/2018/11/07/JS里的数据类型转换/</id>
    <published>2018-11-07T13:05:32.000Z</published>
    <updated>2018-11-07T14:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍JS里的数据类型如何进行类型转换，<code>Symbol</code>类型不讨论<br><a id="more"></a></p><!-- toc --><h2 id="任意类型转换成Number类型"><a href="#任意类型转换成Number类型" class="headerlink" title="任意类型转换成Number类型"></a>任意类型转换成Number类型</h2><h3 id="1-Number-a"><a href="#1-Number-a" class="headerlink" title="1.Number(a)"></a>1.Number(a)</h3><blockquote><p>除了要转换的类型本身内容是数字将被转换成对应的number，其余类型都会被转换成<code>NaN</code>(非数字)</p></blockquote><pre><code>Number(&apos;1&apos;)        //1Number(&apos;s&apos;)        //NaNNumber(&apos;null&apos;)    //0Number(&apos;undefined&apos;)    //NaNobj = {a:5}Number(obj)        //NaNfunction a(){ return 1;}    //NaNNumber(a)</code></pre><h3 id="2-parseInt-a-b"><a href="#2-parseInt-a-b" class="headerlink" title="2.parseInt(a,b)"></a>2.parseInt(a,b)</h3><blockquote><p>将字符串转换成整数类型，第一个参数代表要转换的内容，第二个参数代表要转换成什么进制。一般选择十进制。进制取值为2~37</p></blockquote><pre><code>parseInt(&apos;011&apos;,10)        //11parseInt(&apos;0x11&apos;,10)        //0parseInt(&apos;011&apos;,36)        //37parseInt(&apos;0x11&apos;)        //17parseInt(&apos;08&apos;)            //8parseInt(&apos;011&apos;,2)        //3</code></pre><h3 id="3-parseFloat-a"><a href="#3-parseFloat-a" class="headerlink" title="3.parseFloat(a)"></a>3.parseFloat(a)</h3><blockquote><p>将字符串转换成浮点数，只能转换成十进制</p></blockquote><pre><code>parseFloat(&apos;3.14&apos;)            //3.14parseFloat(&apos;314e-2&apos;)        //3.14parseFloat(&quot;0.0314E+2&quot;)        //3.14parseFloat(&quot;3.14more non-digit characters&quot;)        //3.14parseFloat(&quot;FF2&quot;)            //NaN</code></pre><h3 id="非常规方法-4-39-1-39-0-amp-5-39-1-39"><a href="#非常规方法-4-39-1-39-0-amp-5-39-1-39" class="headerlink" title="非常规方法 4. &#39;1&#39;-0 &amp; 5. +&#39;1&#39;"></a>非常规方法 4. <code>&#39;1&#39;-0</code> &amp; 5. <code>+&#39;1&#39;</code></h3><blockquote><p>方便的让字符串转换成数字。既能转换成整数，又能转换成浮点数。</p></blockquote><pre><code>&apos;1.23&apos; -0        //1.230+&apos;1.23&apos;        //&quot;1.23&quot;</code></pre><h2 id="2-任意字符转换成String类型"><a href="#2-任意字符转换成String类型" class="headerlink" title="2.任意字符转换成String类型"></a>2.任意字符转换成String类型</h2><h3 id="1-toString-a"><a href="#1-toString-a" class="headerlink" title="1.toString(a)"></a>1.toString(a)</h3><blockquote><p>用toString()方法只能将number类型和Boolean类型转换成字符串。null、undefined会报错，object类型会显示不完全。</p></blockquote><pre><code>var a = 1a.toString()        //&quot;1&quot;var b = trueb.toString()        //&quot;true&quot;var c = nullc.toString()        //Cannot read property &apos;toString&apos; of nullvar d = undefined    //Cannot read property &apos;toString&apos; of nulld.toString()var obj = { a:1 }obj.toString()        //&quot;[object Object]&quot;</code></pre><h3 id="2-String-a"><a href="#2-String-a" class="headerlink" title="2.String(a)"></a>2.String(a)</h3><blockquote><p>用String()是一个全局函数，可以将所有类型转换为字符串</p></blockquote><pre><code>String(1)            //&quot;1&quot;String(null)        //&quot;null&quot;String(undefined)    //&quot;undefined&quot;String(true)        //&quot;true&quot;String(obj)            //&quot;[object Object]&quot;</code></pre><h3 id="非常规方法-3-39-39-x-amp-4-x-39-39"><a href="#非常规方法-3-39-39-x-amp-4-x-39-39" class="headerlink" title="非常规方法 3. &#39;&#39; + x &amp; 4. x + &#39;&#39;"></a>非常规方法 3. <code>&#39;&#39; + x</code> &amp; 4. <code>x + &#39;&#39;</code></h3><blockquote><p>加上一个空字符串就可以快速将其他类型转换成字符串</p></blockquote><pre><code>1 + &apos;&apos;            //&quot;1&quot;null + &apos;&apos;        //&quot;null&quot;undefined + &apos;&apos;    //&quot;undefined&quot;true + &apos;&apos;        //&quot;true&quot;obj + &apos;&apos;        //&quot;[object Object]&quot;</code></pre><h2 id="任意类型转换成Boolean类型"><a href="#任意类型转换成Boolean类型" class="headerlink" title="任意类型转换成Boolean类型"></a>任意类型转换成Boolean类型</h2><h3 id="1-Boolean-a"><a href="#1-Boolean-a" class="headerlink" title="1.Boolean(a)"></a>1.Boolean(a)</h3><blockquote><p>可以转换所有类型为布尔类型</p></blockquote><pre><code>Boolean(1)            //trueBoolean(&apos;s&apos;)        //trueBoolean(null)        //falseBoolean(undefined)    //falseBoolean(obj)        //trueBoolean(function(){})    //true</code></pre><h3 id="非常规方法-2-x"><a href="#非常规方法-2-x" class="headerlink" title="非常规方法 2.!! + x"></a>非常规方法 2.<code>!! + x</code></h3><blockquote><p>这是一种最便捷最快的方式来使其他类型转换为布尔类型</p></blockquote><pre><code>!!1                //true!!null            //false!!undefined        //false!!obj            //true!!&apos;s&apos;            //true</code></pre><ul><li>布尔类型中有五个falsy值，分别是：NaN, 0, null, undefined, ‘’.</li><li>falsy是在Boolean 上下文中认定可转换为false的值.</li><li>对象数据类型无论是空对象还是其他对象，只要是对象转换为布尔值就是true</li><li>MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy</a></li></ul><h2 id="深拷贝VS浅拷贝"><a href="#深拷贝VS浅拷贝" class="headerlink" title="深拷贝VS浅拷贝"></a>深拷贝VS浅拷贝</h2><blockquote><p>注：深拷贝浅拷贝可以通过画内存图了解区别。</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>b变不影响a，这样就是深拷贝。另外基本类型赋值就是深拷贝。</p></blockquote><pre><code>var a = 1    //undefinedvar b = a    //undefinedb = 2        //2a            //1</code></pre><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>b变影响a变，这样就是浅拷贝。</p></blockquote><pre><code>var a = {                //undefinedname:&apos;a&apos;}var b = a                //undefinedb.name=&apos;b&apos;                //&quot;b&quot;a.name                    //&quot;b&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍JS里的数据类型如何进行类型转换，&lt;code&gt;Symbol&lt;/code&gt;类型不讨论&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS里的数据类型</title>
    <link href="/2018/11/04/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>/2018/11/04/JS里的数据类型/</id>
    <published>2018-11-04T14:48:32.000Z</published>
    <updated>2018-11-07T13:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍JS里的7种数据类型<br><a id="more"></a></p><!-- toc --><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>JS中值可以分为七个类型，分别是数值（number），字符串（string），布尔值（boolean），undefined，null，对象（object）和ES6新增的symbol。其中，数值、字符串、布尔类型、undefined、null被称为基本数据类型，对象被称为复杂数据类型，即基本类型的集合，对象包括array和function。</p><h3 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h3><p>JavaScript 浮点数由64个二进制位组成</p><ul><li>第1位：符号位，0表示正数，1表示负数</li><li>第2位到第12位（共11位）：指数部分</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul><h3 id="有以下四种常用进制"><a href="#有以下四种常用进制" class="headerlink" title="有以下四种常用进制:"></a>有以下四种常用进制:</h3><ol><li>十进制：没有前导0的数值。</li><li>八进制：有前缀0o或0O的数值。</li><li>十六进制：有前缀0x或0X的数值。</li><li>二进制：有前缀0b或0B的数值。</li></ol><h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><p>1.正负0，基本相同，只有是作为分母情况下，它们返回的值不同</p><p><img src="https://i.loli.net/2018/11/05/5bdff5aae8eb3.jpg" alt=""></p><p>2.<code>NaN</code>是指非数字的特殊值，用于字符串解析成数字出错的场合。但是<code>NaN</code>的类型为<code>number</code>。并且<code>NaN</code>参与运算（包括自己）,得出结果都是<code>NaN</code>。</p><p>3.<code>Infinity</code>表示’无穷’，用在正值过大或负值过小的情况下。有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p><h4 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h4><pre><code>var a = &apos;Hello world&apos;</code></pre><h4 id="多行书写长字符串"><a href="#多行书写长字符串" class="headerlink" title="多行书写长字符串"></a>多行书写长字符串</h4><blockquote><p>结尾不能带空格</p></blockquote><pre><code>var longString = &apos;Long \long \long \string&apos;;</code></pre><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>转义字符用来表示一些特殊字符。用反斜杠表示，如下：</p><pre><code>\0 ：null（\u0000）\b ：后退键（\u0008）\f ：换页符（\u000C）\n ：换行符（\u000A）\r ：回车键（\u000D）\t ：制表符（\u0009）\v ：垂直制表符（\u000B）\&apos; ：单引号（\u0027）\&quot; ：双引号（\u0022）\\ ：反斜杠（\u005C）</code></pre><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>布尔类型只有<code>true</code>和<code>false</code>两种状态。转换规则除了<code>undefined、null、false、0、NaN、&quot; &quot;或&quot;&quot;(空字符串)</code>会被转为false,其他值都视为true。</p><h3 id="undefined-amp-null类型"><a href="#undefined-amp-null类型" class="headerlink" title="undefined&amp;null类型"></a>undefined&amp;null类型</h3><p><code>null</code>与<code>undefined</code>都表示“没有”，分为两种类型。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>变量没有复制，则为<code>undefined</code>。</li><li>有一个对象<code>object</code>，现在不想赋值，则推荐使用<code>null</code>。有一个非对象，没有赋值，推荐使用<code>undefined</code></li></ol><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><blockquote><p><code>object</code>是复杂类型，除了<code>object</code>类型，其他6种类型都是简单类型。</p></blockquote><p><code>object</code>是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。如:</p><pre><code>var obj = {  foo: &apos;Hello&apos;,  bar: &apos;World&apos;};</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考链接：<a href="https://wangdoc.com/javascript" target="_blank" rel="noopener">https://wangdoc.com/javascript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍JS里的7种数据类型&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结</title>
    <link href="/2018/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <id>/2018/10/27/数据结构总结/</id>
    <published>2018-10-27T06:04:36.000Z</published>
    <updated>2018-10-31T08:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人对数据结构基础知识总结: hash，queue，stack，链表，树，排序算法等<br><a id="more"></a></p><!-- toc --><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数据结构笔记</p></blockquote><p><img src="https://i.loli.net/2018/10/31/5bd9405f75e82.jpg" alt="&quot;随笔&quot;"></p><p><img src="https://i.imgur.com/PO5tYDf.jpg" alt="&quot;随笔&quot;"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>排序算法中有一个叫做“归并排序”或者“合并排序”的算法，它用到的就是分而治之的思想，而它的时间复杂度就是N*logN，此算法采用的是二分法，所以可以认为对应的对数函数底数为2，也有可能是三分法，底数为3，以此类推。</p><h3 id="堆排序时间复杂度"><a href="#堆排序时间复杂度" class="headerlink" title="堆排序时间复杂度:"></a>堆排序时间复杂度:</h3><p>初始化堆栈过程时间：O(n)</p><p>更改堆元素后重建堆时间：O(nlogn)</p><h3 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h3><p>规则（1.堆排序的二叉树必须是完全二叉树 2.从右往左依次遍历）</p><ol><li>先比较最右边相邻叶子节点谁的值大，较大值的叶子节点与其父节点比较。若父节点较大则key值不换，若父节点较小则与叶子节点交换key值。</li><li>根据过程1的步骤从右往左依次遍历其余相邻叶子节点与其父节点。</li><li>比较 “倒数2层级组成的小树” 最右边的相邻节点谁的值大，较大值的节点与其父节点比较。若其父节点较大则key值不换。若其父节点较小则与该节点交换key值，并且进行过程1，2。</li><li>根据过程1的步骤从右往左依次遍历其余相邻节点与其父节点。</li><li>比较 “倒数3层级组成的小树” 最右边的相邻节点谁的值大，较大值的节点与其父节点比较。若其父节点较大则key值不换。若其父节点较小则与该节点交换key值，并且进行过程3，4。</li><li>重复以上操作推理的下一步操作，直到确定到根节点的key值。</li><li>然后将根节点与最右边叶子节点交换key值，取消该叶子节点的堆排序过程。</li><li>将根节点与其子节点较大者的key值进行比较，若根节点大则不交换，若根节点小则交换Key值。重复推理操作，若中途不交换则结束比较，否则依次比较每个层次父节点与子节点大小，并且交换key值直至叶子节点。</li><li>重复过程7，8。直到堆排序完成。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人对数据结构基础知识总结: hash，queue，stack，链表，树，排序算法等&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
      <category term="计算机基础" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局与定位常用方法</title>
    <link href="/2018/10/23/CSS%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>/2018/10/23/CSS布局与定位常用方法/</id>
    <published>2018-10-23T02:30:46.000Z</published>
    <updated>2018-10-24T07:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍左右布局，左中右布局，水平居中，垂直居中等常用技巧。<br><a id="more"></a></p><!-- toc --><h2 id="CSS布局与定位"><a href="#CSS布局与定位" class="headerlink" title="CSS布局与定位"></a>CSS布局与定位</h2><blockquote><p>本次主要介绍如何使用CSS作出<br>左右布局<br>左中右布局<br>水平居中<br>垂直居中<br>等其他小技巧</p></blockquote><h3 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h3><p>方法：<br>1.给子元素设置浮动float:left&amp;right，父元素清除浮动clearfix。<br>作用：清除浮动效果后父元素的塌陷。</p><pre><code>.clearfix::after{  content: &apos;&apos;;  display: block;  clear: both;}</code></pre><p>代码：</p><pre><code>html:&lt;div class=&quot;baba clearfix&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;css:.clearfix::after{  content: &apos;&apos;;  display: block;  clear: both;}.baba{  border: 1px solid red;  width: 300px;;}.left{  width: 50%;  height: 100px;  background: #000;  float: left;}.right{  width: 50%;  height: 100px;  background: green;  float: left;　}</code></pre><p> <img src="https://i.imgur.com/7fESYeu.jpg" alt="直接float"></p><p>2.绝对定位</p><p><img src="https://i.imgur.com/lui4wge.jpg" alt="绝对定位"></p><p>3.inline-block</p><p><img src="https://i.imgur.com/3KAXgvy.jpg" alt="inline-block"></p><h3 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h3><p>方法：和左右布局一样，float+clearfix</p><p><img src="https://i.imgur.com/LofK7Pg.jpg" alt=""></p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="内联元素方法："><a href="#内联元素方法：" class="headerlink" title="内联元素方法："></a>内联元素方法：</h4><p>父元素身上写text-align:center;</p><p><img src="https://i.imgur.com/UPtO3sH.jpg" alt=""></p><p>除了文本类型，div类型block属性变成inline-block可以实现同行效果。</p><h4 id="内联元素方法：-1"><a href="#内联元素方法：-1" class="headerlink" title="内联元素方法："></a>内联元素方法：</h4><blockquote><p>div类型实现分行效果。</p></blockquote><p><img src="https://i.imgur.com/dCDrSCO.jpg" alt=""></p><h3 id="垂直居中7种方法"><a href="#垂直居中7种方法" class="headerlink" title="垂直居中7种方法"></a>垂直居中7种方法</h3><p>1.水平垂直居中</p><p><img src="https://i.imgur.com/hR7evlQ.jpg" alt=""></p><p>2.利用margin:auto来实现居中</p><p><img src="https://i.imgur.com/9p2OKUR.jpg" alt=""></p><p>3.使用父元素table &amp; 子元素table-cell布局，实现水平和垂直居中</p><blockquote><p>同时可以设置table-cell高度。</p></blockquote><p><img src="https://i.imgur.com/ETLLVt8.jpg" alt=""></p><p>4.使用绝对定位，position: absolute;top: 50%;left: 50%; margin-top: -50px; margin-left: -50% (这是在知道该元素的具体高度和宽度)</p><p><img src="https://i.imgur.com/fjSSIlX.jpg" alt=""></p><p>5.使用绝对定位，不知道具体的高度和宽度。position: absolute;top: 50%;left: 50%;transform：translate(-50%,-50%)</p><p><img src="https://i.imgur.com/5eEG0bV.jpg" alt=""></p><p>6.使用flex。 在父元素上面设置： display: flex; justify-content: center; align-items: center</p><p><img src="https://i.imgur.com/9CV5fIw.jpg" alt=""></p><p>7.使用绝对定位，margin。 在子元素上面设置：position: absolute；top:0;bottom: 0;right: 0;left: 0; margin: auto</p><blockquote><p>可以固定div垂直居中。</p></blockquote><p><img src="https://i.imgur.com/5EPvrqx.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍左右布局，左中右布局，水平居中，垂直居中等常用技巧。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS display常用属性浅析</title>
    <link href="/2018/10/21/CSS-display%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/"/>
    <id>/2018/10/21/CSS-display常用属性浅析/</id>
    <published>2018-10-21T08:59:33.000Z</published>
    <updated>2018-10-24T07:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS display的几个常用的属性值，inline ， block， inline-block<br><a id="more"></a></p><!-- toc --><h2 id="CS-display属性"><a href="#CS-display属性" class="headerlink" title="CS display属性"></a>CS display属性</h2><p>display的几个常用的属性值，inline ， block， inline-block</p><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline元素只能包含inline元素。<br>2.inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，<br>才会新换一行，其宽度随元素的内容而变化。<br>3.inline元素设置width,height属性无效，如果你要改变内联元素的行高即类似文本的行<br>间距，那么你只能使用这三个属性：line-height，font-size，vertical-align。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>1.block元素可以包含block元素和inline元素，块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如&lt;form只能包含块级元素；p 元素，只能包含inline元素，而不能包含block元素，也有一些块级元素既可以包含块级，也可以包含行级元素。<br>2.block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自<br>动填满其父元素宽度。<br>3.block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。当只<br>设置了height属性时，则width默认是其父类元素的宽度。<br>4.block元素可以设置margin和padding属性。</p><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><p>1.inline元素只能包含inline元素。<br>2.inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。<br>3.inline元素设置width,height属性无效，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line-height，font-size，vertical-align。</p><p><img src="image-1.png" alt=""></p><p><span>display: inline</span></p><p><img src="image-2.png" alt=""></p><p><span>display: block-inline</span></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在做项目的过程中，我发现了一个问题。在&lt;span&gt;标签中加入padding属性时不改变对应位置，最后检查后发现是因为span的默认display:block属性，修改后就显示正确了。</p><p><img src="image-30.png" alt=""><br><img src="image-40.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS display的几个常用的属性值，inline ， block， inline-block&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML常用的标签</title>
    <link href="/2018/10/18/HTML%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE/"/>
    <id>/2018/10/18/HTML常用的标签/</id>
    <published>2018-10-18T10:45:06.000Z</published>
    <updated>2018-10-24T07:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML常用的标签简单了解<br><a id="more"></a></p><!-- toc --><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><h3 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;html&gt;</td><td style="text-align:center">代表 HTML 或 XHTML 文档的根。其他所有元素必须是这个元素的子节点</td></tr></tbody></table><h3 id="文档数据"><a href="#文档数据" class="headerlink" title="文档数据"></a>文档数据</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;head&gt;</td><td style="text-align:center">代表关于文档元数据的一个集合，包括脚本或样式表的链接或内容</td></tr><tr><td>&lt;title&gt;</td><td style="text-align:center">定义文档的标题</td></tr><tr><td>&lt;base&gt;</td><td style="text-align:center">定义页面上相对URL的基准URL</td></tr><tr><td>&lt;link&gt;</td><td style="text-align:center">用于链接外部的CSS到该文档</td></tr><tr><td>&lt;meta&gt;</td><td style="text-align:center">定义其他HTML元素无法描述的数据</td></tr><tr><td>&lt;style&gt;</td><td style="text-align:center">用于内联CSS</td></tr></tbody></table><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;script&gt;</td><td style="text-align:center">定义一个内联脚本或链接到外部脚本。脚本语言是 JavaScript</td></tr><tr><td>&lt;noscript&gt;</td><td style="text-align:center">定义当浏览器不支持脚本时显示的替代文字</td></tr><tr><td>&lt;template&gt;</td><td style="text-align:center">通过 JavaScript 在运行时实例化内容的容器</td></tr></tbody></table><h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;body&gt;</td><td style="text-align:center">代表 HTML 文档的内容。在文档中只能有一个 &lt;body&gt; 元素</td></tr><tr><td>&lt;section&gt;</td><td style="text-align:center">定义文档中的一个章节</td></tr><tr><td>&lt;nav&gt;</td><td style="text-align:center">定义只包含导航链接的章节</td></tr><tr><td>&lt;article&gt;</td><td style="text-align:center">定义可以独立于内容其余部分的完整独立内容块</td></tr><tr><td>&lt;aside&gt;</td><td style="text-align:center">定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理</td></tr><tr><td>&lt;h1&gt;到&lt;h6&gt;</td><td style="text-align:center">标题元素实现了六层文档标题，&lt;h1&gt; 是最大的标题，&lt;h6&gt; 是最小的标题。标题元素简要地描述章节的主题</td></tr><tr><td>&lt;header&gt;</td><td style="text-align:center">定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录</td></tr><tr><td>&lt;footer&gt;</td><td style="text-align:center">定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址</td></tr><tr><td>&lt;address&gt;</td><td style="text-align:center">定义包含联系信息的一个章节</td></tr><tr><td>&lt;main&gt;</td><td style="text-align:center">定义文档中主要或重要的内容</td></tr></tbody></table><h3 id="组织内容"><a href="#组织内容" class="headerlink" title="组织内容"></a>组织内容</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;p&gt;</td><td style="text-align:center">定义一个段落</td></tr><tr><td>&lt;hr&gt;</td><td style="text-align:center">分隔符</td></tr><tr><td>&lt;pre&gt;</td><td style="text-align:center">代表其内容以及预先排版过，格式应当保留</td></tr><tr><td>&lt;blockquote&gt;</td><td style="text-align:center">代表引用自其它来源的内容</td></tr><tr><td>&lt;ol&gt;</td><td style="text-align:center">定义一个有序列表</td></tr><tr><td>&lt;ul&gt;</td><td style="text-align:center">定义一个无序列表</td></tr><tr><td>&lt;li&gt;</td><td style="text-align:center">定义列表中的一个列表项</td></tr><tr><td>&lt;dl&gt;</td><td style="text-align:center">定义一个定义列表</td></tr><tr><td>&lt;dt&gt;</td><td style="text-align:center">代表一个由下一个&lt;dd&gt;定义的术语</td></tr><tr><td>&lt;dd&gt;</td><td style="text-align:center">代表出现在它之前之前术语的定义</td></tr><tr><td>&lt;figure&gt;</td><td style="text-align:center">代表一个和文档有关的图例</td></tr><tr><td>&lt;figcaption&gt;</td><td style="text-align:center">代表一个图例的说明</td></tr><tr><td>&lt;div&gt;</td><td style="text-align:center">代表一个通用的容器，没有特殊含义</td></tr></tbody></table><h3 id="文字形式"><a href="#文字形式" class="headerlink" title="文字形式"></a>文字形式</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td style="text-align:center">代表一个链接到其他资源的超链接</td></tr><tr><td>&lt;em&gt;</td><td style="text-align:center">代表强调 文字</td></tr><tr><td>&lt;strong&gt;</td><td style="text-align:center">代表特别重要 文字</td></tr><tr><td>&lt;small&gt;</td><td style="text-align:center">代表注释，如免责声明、版权声明等，对理解文档不重要</td></tr><tr><td>&lt;s&gt;</td><td style="text-align:center">代表不准确或不相关 的内容</td></tr><tr><td>&lt;cite&gt;</td><td style="text-align:center">代表作品标题</td></tr><tr><td>&lt;q&gt;</td><td style="text-align:center">代表内联的引用</td></tr><tr><td>&lt;dfn&gt;</td><td style="text-align:center">代表一个术语包含在其最近祖先内容中的定义</td></tr><tr><td>&lt;abbr&gt;</td><td style="text-align:center">代表省略 或缩写 ，其完整内容在 title 属性中</td></tr><tr><td>&lt;data&gt;</td><td style="text-align:center">关联一个内容的机器可读的等价形式</td></tr><tr><td>&lt;time&gt;</td><td style="text-align:center">代表日期 和时间 值</td></tr><tr><td>&lt;code&gt;</td><td style="text-align:center">代表计算机代码</td></tr><tr><td>&lt;var&gt;</td><td style="text-align:center">代表代码中的变量</td></tr><tr><td>&lt;sub&gt;,&lt;sup&gt;</td><td style="text-align:center">分别代表下标 和上标</td></tr><tr><td>&lt;u&gt;</td><td style="text-align:center">代表一段需要下划线呈现的文本注释，如标记出拼写错误的文字等</td></tr><tr><td>&lt;mark&gt;</td><td style="text-align:center">代表一段需要被高亮的引用 文字</td></tr><tr><td>&lt;ruby&gt;</td><td style="text-align:center">代表被ruby 注释 标记的文本，如中文汉字和它的拼音</td></tr><tr><td>&lt;rt&gt;</td><td style="text-align:center">代表ruby 注释 ，如中文拼音</td></tr><tr><td>&lt;rp&gt;</td><td style="text-align:center">代表 ruby 注释两边的额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示</td></tr><tr><td>&lt;bdi&gt;</td><td style="text-align:center">代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本</td></tr><tr><td>&lt;span&gt;</td><td style="text-align:center">代表一段没有特殊含义的文本，当其他语义元素都不适合文本时候可以使用该元素</td></tr><tr><td>&lt;br&gt;</td><td style="text-align:center">代表换行</td></tr><tr><td>&lt;wbr&gt;</td><td style="text-align:center">代表建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符</td></tr></tbody></table><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;ins&gt;</td><td style="text-align:center">定义增加 到文档的内容</td></tr><tr><td>&lt;del&gt;</td><td style="text-align:center">定义从文档移除 的内容</td></tr></tbody></table><h3 id="嵌入内容"><a href="#嵌入内容" class="headerlink" title="嵌入内容"></a>嵌入内容</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td style="text-align:center">代表一张图片</td></tr><tr><td>&lt;iframe&gt;</td><td style="text-align:center">代表一个内联的框架</td></tr><tr><td>&lt;embed&gt;</td><td style="text-align:center">代表一个嵌入 的外部资源，如应用程序或交互内容</td></tr><tr><td>&lt;object&gt;</td><td style="text-align:center">代表一个外部资源 ，如图片、HTML 子文档、插件等</td></tr><tr><td>&lt;video&gt;</td><td style="text-align:center">代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面</td></tr><tr><td>&lt;audio&gt;</td><td style="text-align:center">代表一段声音 ，或音频流</td></tr><tr><td>&lt;source&gt;</td><td style="text-align:center">为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定媒体源</td></tr><tr><td>&lt;track&gt;</td><td style="text-align:center">为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定文本轨道（字幕）</td></tr><tr><td>&lt;canvas&gt;</td><td style="text-align:center">代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等</td></tr><tr><td>&lt;map&gt;</td><td style="text-align:center">与 &lt;area&gt; 元素共同定义图像映射 区域</td></tr><tr><td>&lt;area&gt;</td><td style="text-align:center">与 &lt;map&gt; 元素共同定义图像映射 区域</td></tr><tr><td>&lt;svg&gt;</td><td style="text-align:center">定义一个嵌入式矢量图</td></tr><tr><td>&lt;math&gt;</td><td style="text-align:center">定义一段数学公式</td></tr></tbody></table><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td style="text-align:center">定义多维数据</td></tr><tr><td>&lt;caption&gt;</td><td style="text-align:center">代表表格的标题</td></tr><tr><td>&lt;colgroup&gt;代表表格中一组单列或多列</td></tr><tr><td>&lt;col&gt;</td><td style="text-align:center">代表表格中的列</td></tr><tr><td>&lt;tbody&gt;</td><td style="text-align:center">代表表格中一块具体数据 （表格主体）</td></tr><tr><td>&lt;thead&gt;</td><td style="text-align:center">代表表格中一块列标签 （表头）</td></tr><tr><td>&lt;tfoot&gt;</td><td style="text-align:center">代表表格中一块列摘要 （表尾）</td></tr><tr><td>&lt;tr&gt;</td><td style="text-align:center">代表表格中的行</td></tr><tr><td>&lt;td&gt;</td><td style="text-align:center">代表表格中的单元格</td></tr><tr><td>&lt;th&gt;</td><td style="text-align:center">代表表格中的头部单元格</td></tr></tbody></table><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td style="text-align:center">代表一个表单 ，由控件组成</td></tr><tr><td>&lt;fieldset&gt;</td><td style="text-align:center">代表控件组</td></tr><tr><td>&lt;legend&gt;</td><td style="text-align:center">代表 &lt;fieldset&gt; 控件组的标题</td></tr><tr><td>&lt;label&gt;</td><td style="text-align:center">代表表单控件的标题</td></tr><tr><td>&lt;input&gt;</td><td style="text-align:center">代表允许用户编辑数据的数据区 （文本框、单选框、复选框等）</td></tr><tr><td>&lt;button&gt;</td><td style="text-align:center">代表按钮</td></tr><tr><td>&lt;select&gt;</td><td style="text-align:center">代表下拉框</td></tr><tr><td>&lt;datalist&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入 代表提供给其他控件的一组预定义选项</td></tr><tr><td>&lt;optgroup&gt;</td><td style="text-align:center">代表一个选项分组</td></tr><tr><td>&lt;option&gt;</td><td style="text-align:center">代表一个 &lt;select&gt; 元素或 &lt;datalist&gt; 元素中的一个选项</td></tr><tr><td>&lt;textarea&gt;</td><td style="text-align:center">代表多行文本框</td></tr><tr><td>&lt;keygen&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入    代表一个密钥对生成器 控件</td></tr><tr><td>&lt;output&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入    代表计算值</td></tr><tr><td>&lt;progress&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入 代表进度条</td></tr><tr><td>&lt;meter&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入    代表滑动条</td></tr></tbody></table><h3 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h3><table><thead><tr><th>Element</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>&lt;details&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入    代表一个用户可以(点击)获取额外信息或控件的小部件</td></tr><tr><td>&lt;summary&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入    代表 &lt;details&gt; 元素的综述 或标题</td></tr><tr><td>&lt;menuitem&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入 代表一个用户可以点击的菜单项</td></tr><tr><td>&lt;menu&gt;</td><td style="text-align:center">这个元素在 HTML5 中加入 代表菜单</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML常用的标签简单了解&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>了解空标签和可替换标签</title>
    <link href="/2018/10/16/%E4%BA%86%E8%A7%A3%E7%A9%BA%E6%A0%87%E7%AD%BE%E5%92%8C%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE/"/>
    <id>/2018/10/16/了解空标签和可替换标签/</id>
    <published>2018-10-16T11:00:27.000Z</published>
    <updated>2018-10-24T07:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解空标签和可替换元素的具体含义，有哪些空标签。<br><a id="more"></a></p><!-- toc --><h2 id="空标签"><a href="#空标签" class="headerlink" title="空标签"></a>空标签</h2><blockquote><p>空标记就是不标记任何内容的标记。而非空标记就是标记有内容的标记。如 &lt;br/&gt; &lt;img/&gt;</p></blockquote><h3 id="HTML中含有以下空元素"><a href="#HTML中含有以下空元素" class="headerlink" title="HTML中含有以下空元素"></a>HTML中含有以下空元素</h3><pre>    &lt;area>    &lt;base>    &lt;br>    &lt;col>    &lt;colgroup> when the span is present    &lt;command>    &lt;embed>    &lt;hr>    &lt;img>    &lt;input>    &lt;keygen>    &lt;link>    &lt;meta>    &lt;param>    &lt;source>    &lt;track>    &lt;wbr>    Note: 在极少数情况下，空元素被错误地称为“无效元素”(void elements)。</pre><h2 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h2><blockquote><p>CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类 外观渲染独立于CSS的 外部对象。</p></blockquote><h3 id="可替换元素概念"><a href="#可替换元素概念" class="headerlink" title="可替换元素概念"></a>可替换元素概念</h3><pre>典型的可替换元素有 &lt;img>、 &lt;object>、 &lt;video> 和 表单元素，如&lt;textarea>、 &lt;input> 。 某些元素只在一些特殊情况下表现为可替换元素，例如 &lt;audio> 和 &lt;canvas> 。 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素（anonymous replaced elements）。CSS在某些情况下会对可替换元素做特殊处理，比如计算外边距和一些auto值。需要注意的是，一部分（并非全部）可替换元素，本身具有尺寸和基线（baseline），会被像vertical-align之类的一些 CSS 属性用到。</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解空标签和可替换元素的具体含义，有哪些空标签。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>简单了解HTTP请求与响应</title>
    <link href="/2018/10/15/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
    <id>/2018/10/15/简单了解HTTP请求与响应/</id>
    <published>2018-10-15T01:29:00.000Z</published>
    <updated>2018-10-24T07:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍 HTTP 请求和响应是什么，如何用Chrome开发者工具查看 HTTP 请求和响应内容，以及如何使用 curl 命令<br><a id="more"></a></p><!-- toc --><blockquote><p>简单介绍 HTTP 请求和响应是什么，如何用Chrome开发者工具查看 HTTP 请求和响应内容，以及如何使用 curl 命令</p></blockquote><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><blockquote><p>什么是HTTP请求？</p></blockquote><head><meta name="generator" content="Hexo 3.8.0"><br><strong>HTTP请求</strong>是指从客户端到服务器端的请求消息。包括：消息首行中，对资源的请求方法、资源的标识符及使用的协议。<br><img src="image1.png" alt=""><br></head><h3 id="HTTP请求包括4部分"><a href="#HTTP请求包括4部分" class="headerlink" title="HTTP请求包括4部分"></a>HTTP请求包括4部分</h3><pre>1 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据1.请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）2.第三部分永远都是一个回车（\n）3.动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等4.这里的路径包括「查询参数」，但不包括「锚点」5.如果你没有写路径，那么路径默认为 /6.第 2 部分中的 Content-Type 标注了第 4 部分的格式</pre><h3 id="如何用Chrome开发者工具查看-HTTP-请求内容"><a href="#如何用Chrome开发者工具查看-HTTP-请求内容" class="headerlink" title="如何用Chrome开发者工具查看 HTTP 请求内容"></a>如何用Chrome开发者工具查看 HTTP 请求内容</h3><p>首先要打开 Network<br><img src="image-2.png" alt=""><br>地址栏输入网址<br><img src="image-3.png" alt=""><br>在 Network 点击，查看 request，点击「view source」<br><img src="image-4.png" alt=""><br><img src="image-5.png" alt=""><br>可以看到请求的前三部分了(第三部分只有换行所以不显示)<br><img src="image-6.png" alt=""><br>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</p><p>如果你想要知道POST请求内容的话，可以尝试网站的登录功能，因为登录时需要提交数据。<br><img src="image-7.png" alt=""><br>注意:要点击 Perserve log ,防止页面刷新。<br><img src="image-8.png" alt=""><br></p><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><blockquote><p>什么是HTTP响应？</p></blockquote><head><meta name="generator" content="Hexo 3.8.0"><br><strong>HTTP响应</strong>是指来自服务器的响应。<br></head><h3 id="HTTP响应包括4部分"><a href="#HTTP响应包括4部分" class="headerlink" title="HTTP响应包括4部分"></a>HTTP响应包括4部分</h3><pre>1 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容第 2 部分中的 Content-Type 标注了第 4 部分的格式第 2 部分中的 Content-Type 遵循 MIME 规范<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP状态码含义查询</a></pre><h3 id="如何用Chrome开发者工具查看-HTTP-请求内容-1"><a href="#如何用Chrome开发者工具查看-HTTP-请求内容-1" class="headerlink" title="如何用Chrome开发者工具查看 HTTP 请求内容"></a>如何用Chrome开发者工具查看 HTTP 请求内容</h3><p>打开 Network<br><img src="image-2.png" alt=""><br>输入网址<br><img src="image-3.png" alt=""><br>选中第一个响应<br><img src="image-9.png" alt=""><br>查看 Response Headers，点击「view parsed」你会看到响应的前两部分<br><img src="image-10.png" alt=""><br>查看 Response 或者 Preview，你会看到响应的第 4 部分<br><img src="image-11.png" alt=""></p><h2 id="如何使用-curl-命令"><a href="#如何使用-curl-命令" class="headerlink" title="如何使用 curl 命令"></a>如何使用 curl 命令</h2><blockquote><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具</p></blockquote><h3 id="例如-curl-s-v-H-“xxx-yyy”-–-“-https-www-baidu-com-“"><a href="#例如-curl-s-v-H-“xxx-yyy”-–-“-https-www-baidu-com-“" class="headerlink" title="例如 curl -s -v -H “xxx: yyy” – “ https://www.baidu.com “"></a>例如 curl -s -v -H “xxx: yyy” – “ <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> “</h3><p><pre><br>    -s，-silent  不显示进度表或错误消息<br>    -v，-verbose  显示请求和响应<br>    -H，-header&lt;header&gt;  添加一个响应头<br>    –  “ <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> “   把你要响应的网址写在 “– ” 后<br></pre><br><img src="image-12.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍 HTTP 请求和响应是什么，如何用Chrome开发者工具查看 HTTP 请求和响应内容，以及如何使用 curl 命令&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>linux的常用命令</title>
    <link href="/2018/10/14/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>/2018/10/14/Linux的常用命令/</id>
    <published>2018-10-14T13:55:29.000Z</published>
    <updated>2018-10-24T07:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>LINUX一些常用命令简单了解<br><a id="more"></a></p><!-- toc --><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><blockquote><p><strong>ls命令</strong>用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。下面会列出一些ls命令常用参数。</p></blockquote><ul><li>ls -1 参数<br>  每行列出一个文件。<br>  <br></li><li>ls -a 参数<br>  列出所有文件，包括隐藏文件。<br>  <br></li><li>ls -la 参数<br>  所有文件的长格式列表（权限，所有权，大小和修改日期）。<br>  <br></li><li>ls -lh 参数<br>  使用人类可读单位（KB，MB，GB）显示大小的长格式列表。<br>  <br></li><li>ls -ls 参数<br>  按大小排序的长格式列表（按降序排序）。<br>  <br></li><li>ls -ltr 参数<br>  所有文件的长格式列表，按修改日期排序（按最早时间开始排序）。<br>  <br></li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><blockquote><p><strong>cat命令</strong>的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</p></blockquote><ul><li>cat file 指令<br>   含义：一次显示整个文件。<br>   <br></li><li>cat file1 file2 &gt; target_file 指令<br>  含义：将多个文件连接到目标文件中。<br>  <br></li><li>cat file1 file2 &gt;&gt; target_file 指令<br>  含义：将几个文件附加到目标文件中。<br>  <br></li><li>cat -n file 参数指令<br>  含义：编号所有输出行<br>  <br></li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><blockquote><p><strong>mv命令</strong>是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。</p></blockquote><ul><li>mv 参数<br>  在任意位置移动文件。<br>  <br></li><li>mv -f 参数<br>  在覆盖现有文件之前不要提示确认。<br>  <br></li><li>mv -fi 参数<br>  在覆盖现有文件之前不要提示确认，但在覆盖之前写入标准错误。<br>  <br></li><li>mv -v参数<br>  以详细模式移动文件，在移动文件后显示文件。<br>  <br></li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><blockquote><p><strong>touch命令</strong>有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。</p></blockquote><ul><li>touch filename指令<br>  创建新的空文件或将现有文件的时间更改为当前时间。<br>  <br></li><li>touch -t YYYYMMDDHHMM.SS filename指令<br>  将文件上的时间设置为特定的日期和时间。<br>  <br></li><li>touch -r filename filename2指令<br>  使用文件中的时间设置第二个文件的时间。<br>  <br></li></ul><h2 id="如何使用-explainshell-com-网站"><a href="#如何使用-explainshell-com-网站" class="headerlink" title="如何使用 explainshell.com 网站"></a>如何使用 explainshell.com 网站</h2><p>当你想查询LINUX下命令的参数时候，可以访问explainshell.com 网站以便节省时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LINUX一些常用命令简单了解&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="命令" scheme="/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Git入门教程</title>
    <link href="/2018/10/12/Git%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>/2018/10/12/Git入门教程/</id>
    <published>2018-10-12T02:13:19.000Z</published>
    <updated>2018-10-28T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍git本地库创建和上传到githup的命令。<br><a id="more"></a></p><!-- toc --><h3 id="git-init命令"><a href="#git-init命令" class="headerlink" title="git init命令"></a>git init命令</h3><p>git init命令的作用是在当前目录新建一个Git代码库。通过建立本地Git代码库，可以上传和下载Githup上的代码。方便我们保留和分享代码。</p><p><br>     </p><h3 id="git-add命令"><a href="#git-add命令" class="headerlink" title="git add命令"></a>git add命令</h3><p>git add命令的作用是添加指定文件到暂存区，当我们使用git commit命令时，git将依据暂存区中的内容来进行文件的提交。</p><p><br>     </p><h3 id="git-commit-v命令"><a href="#git-commit-v命令" class="headerlink" title="git commit -v命令"></a>git commit -v命令</h3><p>git commit -v主要是将暂存区里的改动提交到本地的版本库，并且提交时显示所有diff信息。然后通过pull和push命令可以将本地git代码库上传到远程git代码库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍git本地库创建和上传到githup的命令。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="命令" scheme="/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-05-测试文章</title>
    <link href="/2018/02/06/111/"/>
    <id>/2018/02/06/111/</id>
    <published>2018-02-06T02:13:19.000Z</published>
    <updated>2018-10-24T07:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是文章的概览，显示在主页缩略内容上面<br><a id="more"></a></p><p>这里是自动生成的文章目录<br><!-- toc --></p><blockquote><p>CSDN的发布流程烂到家了，只能自己动手搭建技术博客</p></blockquote><h1 id="这是大标题"><a href="#这是大标题" class="headerlink" title="这是大标题"></a>这是大标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h2 id="这里有个本地图片"><a href="#这里有个本地图片" class="headerlink" title="这里有个本地图片"></a>这里有个本地图片</h2><p><img src="image-1.png" alt=""></p><h2 id="这里有个网络图片"><a href="#这里有个网络图片" class="headerlink" title="这里有个网络图片"></a>这里有个网络图片</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79gw1fb0neee6mlj30dw0aldgf.jpg" alt=""></p><h2 id="文章结束"><a href="#文章结束" class="headerlink" title="文章结束"></a>文章结束</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是文章的概览，显示在主页缩略内容上面&lt;br&gt;
    
    </summary>
    
    
      <category term="测试" scheme="/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
